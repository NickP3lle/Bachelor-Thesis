\documentclass{article}

\title{JWT Tokens}
\author{Nicolò Pellegrinelli}
\date{April 15, 2024}

\usepackage{graphicx}
% \usepackage{animate}
\usepackage{hyperref}
\usepackage{parskip}
\usepackage{bookmark}
\usepackage{amsmath}
\usepackage{upquote}

\begin{document}
\sloppy

\maketitle

\section{Introduzione}
JSON Web Token (JWT) è uno standard aperto (RFC 7519) che definisce un modo compatto per trasmettere informazioni in modo sicuro tra due parti come oggetti JSON.
Queste informazioni possono essere verificate e attendibili perché sono firmate digitalmente.

Le firme digitali possono essere generate utilizzando algoritmi HMAC (chiave segreta), RSA (coppia chiave pubblica/privata) o ECC (curve ellittiche).

\section{Usi}
\begin{itemize}
	\item \textbf{Autorizzazione}: Una volta che un utente si è autenticato, il server può generare un JWT, che può essere utilizzato per accedere a risorse specifiche senza dover autenticare l'utente ogni volta.
	      Questo è utile per le API RESTful, dove l'autenticazione è necessaria per ogni richiesta.
	      Single Sign On (SSO) è un altro esempio di utilizzo di JWT per l'autenticazione.
	\item \textbf{Scambio di informazioni}: Poiché i JWT possono essere firmati, si può essere sicuri che il mittente sia chi dice di esserlo e che i contenuti del messaggio non siano stati alterati.
\end{itemize}

\section{Struttura di un JWT}
Un JWT è composto da tre parti separate da punti: header, payload e signature.
% \begin{verbatim}
$$header.payload.signature$$
% \end{verbatim}

\subsection{Header}
L'header contiene il tipo di algoritmo di firma utilizzato e il tipo di token.
Questo JSON viene poi codificato in Base64URL, che è una codifica Base64 sicura per gli URL.

\subsection{Payload}

Il payload contiene le informazioni che si desidera trasmettere.
Queste informazioni riguardano un'entità (solitamente l'utente) e i metadati.
Anche questo JSON viene codificato in Base64URL.

È importante notare che il payload non è crittografato, quindi non dovrebbe contenere informazioni sensibili in quanto possono essere lette da chiunque.

\subsection{Signature}
La firma viene generata utilizzando l'header codificato a cui viene aggiunto il payload codificato e una chiave segreta.
Questo risultato viene firmato utilizzando l'algoritmo specificato nell'header.
La firma viene quindi aggiunta al token.

La firma è utilizzata per verificare che il messaggio non sia stato modificato.
Inoltre, se il token è stato firmato con una chiave privata, può anche verificare l'autenticità del mittente.

\section{Come funziona un JWT}
Quando un utente si autentica, un token JWT viene generato e inviato al client.
Ogni volta che l'utente fa una richiesta al server, il token viene inviato insieme alla richiesta.
Il server può quindi verificare la firma del token per assicurarsi che sia valido e che l'utente abbia i permessi necessari per accedere alla risorsa richiesta.

Generalmente i token JWT hanno una scadenza breve per garantire un livello di sicurezza alto.
Questi token sono chiamati Access Tokens e sono quelli utilizzati per l'accesso alle risorse protette.
Un altro tipo di token è il Refresh Token, che viene utilizzato per ottenere un nuovo Access Token una volta che il precedente è scaduto.
I Refresh Token hanno una vita più lunga degli Access Token e interagiscono con gli authorization server invece di quelli dei resource server.

\section{JSON Web Encryption (JWE)}
Il JSON Web Encryption standard stabilisce un modo per crittografare, e quindi rendere oscuri, i contenuti di un JWT.

A primo impatto, potrebbe sembrare che la crittografia abbia le stesse garanzie della firma, con l'aggiunta della riservatezza dei dati.
Tuttavia la crittografia non garantisce l'autenticità dei dati, ma solo la loro riservatezza.

Come per JWS, JWE supporta principalmente due schemi: uno schema a chiave segreta e uno a chiave pubblica.

Lo schema a chiave segreta funziona in modo simile a quello in JWS, in cui ogni parte che detiene la chiave segreta può crittografare e decrittografare i dati.

Lo schema a chiave pubblica, invece, funziona in maniera differente.
In questo caso sono le parti che detengono la chiave pubblica a crittografare i dati, mentre la parte che detiene la chiave privata può decrittografarli.
In pratica, in JWE chi detiene la chiave pubblica può creare nuovi messaggi crittografati, mentre in JWS può solo verificarne l'autenticità.
Questo vuol dire che JWE non fornisce le stesse garanzie di JWS e, quindi, non può rimpiazzare il ruolo della firma.

Per questi motivi JWE è spesso utilizzato in combinazione con JWS: un token JWT crittografato funziona da container per un token JWT firmato in modo da ottere i benefici di entrambi.

\section{JSON Web Signature (JWS)}
Il JSON Web Signature standard stabilisce un singolo algoritmo di firma supportato da tutte le implementazioni: HMAC con SHA-256, chiamato HS256.
In aggiunta, secondo il JSON Web Algorithms standard (JWA), anche altri algoritmi sono raccomandati per l'uso con JWT.
Tra questi RSASSA PKCS1 v1.5 con SHA-256 (RS256) e ECDSA con P-256 a curva ellittica e SHA-256 (ES256).

\section{HMAC}
Keyed-Hash Message Authentication Code (HMAC) è un algoritmo di firma che combina un certo messaggio con una chiave segreta utilizzando una funzione hash crittografica.
Il risultato è un codice di autenticazione che può essere utilizzato per verificare un messaggio solo se le parti generatrice e verificatrice condividono la stessa chiave segreta.

La robustezza della funzione hash garantisce che il messaggio non possa essere modificato senza conoscere la chiave segreta.

In sostanza, HMAC permette di verificare l'integrità e l'autenticità di un messaggio attraverso chiavi segrete condivise.

Sia:
\begin{itemize}
	\item $H$ la funzione hash crittografica
	\item $B$ la lunghezza del blocco di $H$
	\item $K$ la chiave segreta
	\item $K'$ la vera chiave utilizzata da $H$ e derivata da $K$
	\item $ipad$ il byte 0x36 ripetuto $B$ volte (chiamato anche padding interno)
	\item $opad$ il byte 0x5C ripetuto $B$ volte (chiamato anche padding esterno)
	\item $M$ il messaggio
	\item $||$ l'operatore di concatenazione
\end{itemize}

L'algoritmo HMAC è definito come:
\begin{verbatim}

HMAC(K, M) = H((K' xor opad) || H((K' xor ipad) || M))

\end{verbatim}
dove $K'$ è definito come segue:
\begin{itemize}
	\item Se $K$ è più corto di $B$, vengono aggiunti zeri a sinistra per raggiungere la lunghezza di $B$.
	\item Se $K$ è più lungo di $B$, viene calcolato $H(K)$.
	\item Se $K$ è esattamente di $B$ byte, $K'$ è uguale a $K$.
\end{itemize}


\section{RSASSA}
RSASSA è una variazione dell'algoritmo RSA, che è un algoritmo di crittografia a chiave pubblica, adattato alle firme.

Gli algoritmi a chiave pubblica si basano sulla generazione di due chiavi, una privata e una pubblica, per crittografare e decrittografare rispettivamente i dati.

\subsection{RSA}
L'algoritmo RSA si basa sul fatto che la fattorizzare un numero intero composto è considerato un problema difficile e può essere rappresentato come segue:

$$(m^e)^d \equiv m \mod n$$

In cui $m$ è il messaggio originale ed $e$, $d$ e $n$ sono scelti nel seguente modo:
\begin{enumerate}
	\item $p$ e $q$ sono due grandi primi generati casualmente.
	      \begin{itemize}
		      \item Un Random Number Generator (RNG) crittograficamente sicuro dovrebbe essere utilizzato per generare questi numeri.
		      \item Non esistendo modo di generare randomicamente numeri primi, è necessario verificare che i numeri generati siano effettivamente primi.
		      \item I numeri primi devono essere grandi e simili per ordine di grandezza.
	      \end{itemize}
	\item $n$ è il risultato del prodotto $p \cdot q$. Questo numero è il modulo e il suo numero di bit equivale alla lunghezza della chiave.
	\item $\phi(n) = (p - 1) \cdot (q - 1)$ è il quoziente di Eulero ($phi(n)$).
	\item $e$ è un numero intero scelto in modo che $1 < e < \phi(n)$ e $e$ sia coprimo con $\phi(n)$.
	\item $d$ deve soddisfare la congruenza $d \equiv e^{-1} \mod \phi(n)$.
	      \begin{itemize}
		      \item $d$ è l'inverso moltiplicativo di $e$ modulo $\phi(n)$.
		      \item L'equazione può essere riscritta come $e \cdot d \equiv 1 \mod \phi(n)$.
	      \end{itemize}
\end{enumerate}

La chiave pubblica è composta dai valori di $n$ ed $e$, mentre la chiave privata è composta dai valori di $n$ ed $d$.
$p$, $q$ e $\phi(n)$ sono valori che devono essere mantenuti segreti.

\subsection{Firma e Verifica con RSA}
Per firmare un messaggio RSA funziona come segue:
\begin{enumerate}
	\item Un digest del messaggio viene calcolato da una funzione hash.
	\item Il digest viene poi elevato alla potenza di $d$ modulo $n$ (chiave privata).
	\item Il risultato è aggiunto al messaggio come firma.
\end{enumerate}
Per verificare la firma invece:
\begin{enumerate}
	\item La firma viene elevata alla potenza di $e$ modulo $n$ (chiave pubblica). Questo restituisce il digest originale.
	\item Viene calcolato il digest del messaggio ricevuto, utilizzando la stessa funzione hash del passaggio di firma.
	\item Se i due digest sono uguali, la firma è valida.
\end{enumerate}

Questo processo è conosciuto come "Signature Scheme with Appendix" (SSA).
La firma è un "appendice" del messaggio originale in quanto è necessario nel processo di verifica della firma.

In una firma con RSA la chiave privata viene utilizzata creare una firma che per verificarne l'autenticità.
In contrasto, la chiave pubblica può essere utilizzata solo per verificare l'autenticità di un messaggio.
Questo schema permette dunque la possibilità di distribuire in modo sicuro uno-a-molti messaggi firmati: le parti riceventi possono verificare l'autenticità del messaggio mantenendo una copia della chiave pubblica, ma non possono creare nuovi messaggi con essa.

\section{ECDSA}
L'esistenza di algoritmi di fattorizzazione efficienti come il General Number Field Sieve (GNFS) o il Quadratic Sieve (QS) ha reso RSA con chiavi brevi vulnerabile.
Tuttavia, all'aumentare dei numeri da fattorizzare, non solo gli algoritmi di fattorizzazione diventano più efficienti, ma anche l'algoritmo RSA diventa più lento, richiedendo chiavi che crescono ancora più velocemente.
Questo diventa un problema insostenibile sul lungo periodo, in particolare per dispositivi con risorse limitate.
Ciò può potenzialmente rendere RSA insicuro e non più utilizzabile.

Algoritmi a curva ellittica sono un'alternativa più efficiente a RSA.
Tra questi, l'Elliptic Curve Diffie-Hellman (ECDH) per lo scambio di chiavi e l'Elliptic Curve Digital Signature Algorithm (ECDSA) per la firma digitale sono i più comuni.
Anche questi algoritmi generano una coppia di chiavi privata/pubblica, ma utilizza, invece della fattorizzazione di numeri semiprimi, il logaritmo discreto su curve ellittiche.
Le curve ellittiche per la crittografia sono definite dalla seguente equazione di terzo grado:

$$y^2 = x^3 + ax + b$$

dove $a$ e $b$ sono parametri della curva.

Gli algoritmi a curve ellittiche sono definiti su campi primi finiti, ovvero insiemi di numeri interi su cui sono definite due operazioni binarie: somma e moltiplicazione.
Con campo primo finito si intende che il numero di elementi nel campo è un numero primo $p$, quindi una quantità finita. Tutti gli elementi e le operazioni sono definite modulo $p$.

Rendendo il campo finito, gli algoritmi usati per le operazioni matematiche cambiano.
In particolare, il logaritmo discreto deve essere usato al posto del logaritmo normale.

Essendo il campo composto da un numero finito di elementi, si potrebbe pensare che il logaritmo (discreto) diventi un problema semplice, tuttavia, non esiste ad oggi un algoritmo efficiente per la risoluzione del logaritmo discreto su curve ellittiche.
Questa proprietà rende il logaritmo discreto ideale per la crittografia e la firma digitale.

Per rendere però l'algoritmo sicuro, è necessario che la curva, ovvero i parametri $a$ e $b$, sia scelta in modo corretto. In passato alcune curve ellittiche sono state compromesse a causa di parametri deboli.

L'aspetto interessante degli algoritmi a curva ellittica è che la lunghezza della chiave può essere ridotta di molto rispetto a RSA per ottenere lo stesso livello di sicurezza.
Ad esempio, una chiave ECC a 256 bit è considerata sicura quanto una chiave RSA a 3072 bit.

Ciò, oltre che a rendere più efficienti gli algoritmi, semplifica la trasmissione e la memorizzazione delle chiavi.
Il motivo per cui la chiave ECC può essere più corta risiede nell'inesistenza, ad oggi, di algoritmi che risolvono il logaritmo discreto più efficientemente dell'approccio naive o brute-force.

In un suo studio, il matematico Arjen K. Lenstra ha esposto il concetto di "Universal Security" calcolando l'energia necessaria per rompere determinti algoritmi crittografici e comparandola con la quantità di acqua che quell'energia sarebbe in grado di portare a ebollizione.
Con questo metodo, Lenstra ha dimostrato che per rompere una chiave RSA di 228 bit è richiesta meno energia di quella necessaria per portare a ebollizione un cucchiaino d'acqua.
Al contrario, per rompere una chiave ECC a 228 bit è necessaria una quantità di energia che porterebbe a ebollizione l'intera acqua presente sulla Terra.
Per questo livello di sicurezza con RSA è necessaria una chiave di almeno 2380 bit.

\section{Considerazioni sulla Sicurezza di JWT}
Essendo il token firmato, non è possibile modificarlo senza invalidare la firma.
Tuttavia, bisogna considerare alcuni aspetti per garantirne la sicurezza, come la protezione delle chiavi, quella privata nel caso asimmetrico e quella segreta nel caso simmetrico.
Ciò è ugualmente importante nel caso di token crittografati.

Un altro aspetto da considerare è l'invio di token contenenti informazioni sensibili.
In questo caso è obbligatorio utilizzare misure che evitano la divulgazione di queste informazioni.
Un modo per farlo è utilizzare token crittografati.
Un altro modo è quello di utilizzare protocolli sicuri per la trasmissione di dati come HTTPS, che si basa su TLS (Transport Layer Security)
Omettere informazioni sensibili dai token è sicuramente la soluzione più semplice e sicura.

Nel caso in cui firma e crittografia siano necessarie contemporaneamente, è solito firmare il token per crittografarlo successivamente.
Questo previene attacchi in cui la firma viene rimossa come il Signature Stripping Attack.

Esistono, inoltre, anche altre vulnerabilità che possono essere sfruttate per compromettere la sicurezza di un'applicazione che utilizza JWT.

\subsection{Signature Stripping Attack}
Un metodo comune per aggirare la verifica della firma è semplicemente quello di rimuovere la firma dal token.
Essendo le tre parti del token codificate separatamente, l'attacco può essere effettuato facilmente rimuovendo la firma e cambiando l'header.

L'attacco è facilmente prevenibile assicurandosi che il server accetti solo token firmati.

\subsection{Cross-Site Request Forgery Attack (CSRF)}
Attacchi CSRF effettuano richieste non autorizzate verso siti in cui l'utente è autenticato, ingannando il browser a inviare richieste da un sito diverso.

Un elemento nel sito malevolo che contiene l'URL del sito target invia una richiesta ogni volta che viene visitato.
Se il sito target utilizza i cookie per la sessione, questa richiesta conterrà le credenziali dell'utente.

JWT token con breve validità di tempo possono mitigare questo attacco.
Un'altra soluzione è l'utilizzo di speciali campi che vengono aggiunti alle richieste solo quando provengono da un sito autorizzato.
Inoltre, essendo questo un'attacco basato sui cookie, se i token non vengono memorizzati nei cookie, l'attacco non può essere effettuato.

\subsection{Cross-Site Scripting Attack (XSS)}
Gli attacchi XSS consentono a un attaccante di eseguire script nel browser di un utente.
Questo script può essere utilizzato per rubare i token accedendo ai cookie e al localStorage.

Molti attacchi XSS sono causati da una mancata validazione dei dati passati al server.
Infatti, se il backend non sanifica i dati, un attaccante può inserire dati in modo che vengano interpretati come script.

Per risolvere questo problema è sempre necessario sanificare i dati in ingresso e, se vengono usati i cookie per salvare i token, è possibile utilizzare la flag HttpOnly per impedirne l'accesso da parte di script.


\section*{Fonti}
Risorse per questo articolo:

\begin{itemize}
	\item Documentazione JWT: \href{https://jwt.io/introduction}{jwt.io/introduction}
	\item The JWT Handbook: \href{https://auth0.com/resources/ebooks/jwt-handbook}{auth0.com/resources/ebooks/jwt-handbook}
	\item Access Tokens vs Refresh Tokens: \href{https://datatracker.ietf.org/doc/html/rfc6749#section-1.4}{ietf.org/doc/html/rfc6749}
	\item RFC 7519: \href{https://datatracker.ietf.org/doc/html/rfc7519}{ietf.org/doc/html/rfc7519}
	\item ECC Wikipedia: \href{https://en.wikipedia.org/wiki/Elliptic-curve_cryptography}{wikipedia.org/wiki/Elliptic-curve\_cryptography}
	\item ECC Cloudflare Article: \href{https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/}{cloudflare.com/elliptic-curve-cryptography}
	\item Universal Security: \href{https://eprint.iacr.org/2013/635.pdf}{eprint.iacr.org/2013/635.pdf}
\end{itemize}

\end{document}